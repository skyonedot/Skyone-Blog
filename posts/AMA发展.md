---
title: 'AMA发展'
date: '2022-06-01'
---

![Reservoir](https://unsplash.com/blog/content/images/2022/01/Manifest--Blog--4.jpg)
[Part1](https://joecontent.substack.com/p/part-1-a-brief-overview-of-1st-generation)
[Part2](https://joecontent.substack.com/p/part-1-a-brief-overview-of-1st-generation)
[Part3](https://joecontent.substack.com/p/part-3-what-should-the-perfect-amm?utm_source=%2Fprofile%2F95169461-fish&utm_medium=reader2)



![Image](https://raw.githubusercontent.com/skydotone/picture-host/master/20220710161849.png#center)


### Part1

---

#### Uniswap

最基础的即是Uniswap, UniswapV2的核心在于公式 
$$
 x*y=k 
$$
这个恒等公式, 其中k为常数, x和y分别为两种 Token 的**数量,** 相应的函数曲线如下, 注意 这条曲线永远不会出现 x=0 或者 y=0 的情况.:apple: 

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220710161849.png)

举个例子, x为AVAX, y为USDC, 假设最开始的有一个人甲来添加流动性, 目前市场价格为100USDC=1AVAX, 因此, 他将 20AVAX 和 2000USDC 放到池子里, 那么此时 k=40000, 这时候乙来想要将手里的 5AVAX 兑换成 USDC, 那么就要经过甲设定的这个池子, 由于乘积一定是恒等式, 因此👇🏻 

1. $y_{i}=k/x_{i}$,
2. $x_{i}=25$, 
3. 则 $y_{i}=40000/25=1600$, 
4. 由于y的数量由2000变成了1600, 因此乙用 5AVAX 拿走了 400USDC,
5. 这个时候池子里由最开始的 20AVAX+2000USDC 变成了 25AVAX+1600USDC, 则代表AVAX的价格由原来的100跌到了64, 那么由乙做的这笔tx 对于整个池子的**价格影响[Price Impact]** 则是 $(64-100)/100=-36\%$ . 价格影响是 **恒定乘积做市商** 的缺点之一,
6. 为了避免出现巨大的 **Price Impact** , 则需要确保池子足够深, 可以让用户来兑付, 如果池子里有 200万USDC 和 2万AVAX, 则用户乙最终会收到 499.875USDC 造成的影响忽略不计,
7. 这样做的好处则是简单明了, 并且给了任何人都可以为市场提供流动性, 而这一举动 在过去只能是大型金融机构来做.

---

#### Balancer

当我们需要多种资产在一个池子里的时候, 我们可能就会用到Balancer, 其核心公式为:
$$
x^{w_x}y^{w_y}z^{w_z}=k
$$
除此之外, Balancer 允许我们以不同比例向池子里添加配对资产, 比如我们可以不必 50:50 添加流动性, 可以以 80:20 的比例来添加, 这样做的好处 👇🏻

- 你更看好某种资产, 并希望它在你的投资组合中占据更多的份额

- 更高的权重所对应的资产会承受更小的无常损失

> 这里重点讲一下Balancer不同权重的 双代币配比的知识, 首先明确知识点, 其次举例证明 :banana: 
>
> 1. 知识点
>
>    - 更高的权重配比, 代表着 更低的无常损失
>    - 更高的权重配比, 在代币价值升值过程中, 所拿到的利润更大
>    - 相反的 风险在于 更低的权重配比则是更高的无常损失 依旧 更低的权重配比则是代币上涨过程中利润更小
>
> 2. 举例说明
>
>    - 假设, 当前两种代币 分别为 SOL[$x$] 和 USDC[$y$], 当前 SOL 的价格是 10U
>    - 甲想要创造一个 SOL:USDC = 80:20 的池子, 所以 甲创建了一个池子, 里面有 8个SOL 和 20个USDC, 成本是100U
>    - 假设当前 SOL价格涨了, 涨到了20U, 那么当前池子有 6.9个SOL 和 34.5个USDC, 两种Token数量计算过程如下 👇🏻
>      1. $w_{x}=0.8, w_{y}=0.2$, 计算最初的 k 值 : $8^{0.8}*20^{0.2}=k=9.609$ 
>      2. 1SOL = 20U = 20USDC, 所以当前价格下 $x*20:y*1=80:20$ , 则推出 $y=5x$
>      3. 根据 k 不变, 则有 $x^{0.8}*y^{0.2}=x^{0.8}*(5x)^{0.2}=k=9.609$, 因此 x 的值为6.9 相应 y 则是34.5
>    - **验证知识点**
>      1. 一直持有 SOL8个 和 USDC20个 当价格涨上来之后, 价值是 100U --> 180U
>      2. 如果以 80:20 添加/建池子去了, 那么 100U --> 172.5U[6.9\*20 + 34.5\*1], **则无常损失是 7.5U**,**池子价值 172.5U**
>      3. 如果以 50:50 添加/建池子, 那么  100U -->  这里如何计算的可以看下面计算过程
>         1. 100U拿来建 50:50 的池子, 那么一定是 5个SOL : 50个USDC, 此时 k=15.81 
>         2. 当 SOL 由 10U --> 20U的时候,  池子里有 3.54个SOL 和 69个USDC 总价值为 138U
>         3. 无常损失 由 150U --> 128U, **无常损失是 22U**., **池子价值 128U**
>
> 3. **这里先说一个现象** :red_circle: 
>
>    1. 50:50 的池子 用的表达式 是 $x^{0.5}*y^{0.5}=k$, 所以k=15.81
>    2. 之所以用 0.5次幂 是因为上面的一大溜计算都是 [保持比例相应 并且 两者相加为1] 的原则, 所以上面是 0.8次幂和0.2次幂
>    3. 其实用 $x^1*y^1=k$, 算出来的结果是一样的, 只不过中间值k 不同而已 
>    4. 当然, 上面关于 0.8次幂和0.2次幂 也可以相应的换成 1.6次幂和0.4次幂
>    5. **结果一样的, 只是计算方式不同**
>
> 4. 一个关于计算当前池子价值的小技巧, 公式如下
>    $$
>    ∆Pool_{USD}=∏_{i}(∆P_{USD}^i)^{w_i}
>    $$
>    同样以上面的例子 SOL 10U --> 20U, 翻了一倍, 
>
>    即 $∆P_{USD}^{SOL}=2$, 相应的 $w_i=0.8$ , 所以池子的变化是 $2^{0.8}= 1.741$, 
>
>    即池子价值变为原来的 1.741倍, 

---

#### Curve

上面介绍的 Balancer 和 Uni 都是**恒定乘积**, 致命的缺点之一则是价格影响, Curve则是用的**恒定加和**, 可以有效解决这个问题, Curve的核心公式很复杂, 但是可以提炼成如下形式
$$
A*(x+y)+xy=k
$$
其中A是一个放大系数, 取决于池子内的资金情况, 如果池子内变得非常不平衡, A就会减小, 以最小化(x+y), 那这样的话, 就会非常像Uni这样的恒定乘积做市商, 相反的, 如果池子内的资金情况很平衡, 则A会变大, 以最大化(x+y) 池子则会变成 恒定加和做市商

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220710225506.png)

表现则像中间的这条蓝色曲线, 在中间部分的时候, 是恒定加和做市商, 当池子内变得不均衡的时候, 则是像Uni一样的恒定乘积做市商

---

#### Bancor

Bancor的特点在于它提供了100%的无常损失保护, 听起来很棒, 但是这部分的损失 其实是给到了 BNT Token的持有者来承担

---

### Part2

---

#### Uniswap V3

UniswapV2版本允许任何人都可以提供市场流动性, 足够简单明了, 相应的缺点则是无常损失, 价格影响以及资金利用效率, 因此 新一代AMM随之诞生

V3的核心观念在于**集中流动性**, 即你注入的流动性比V2可以更有效的使用率, 以USDC/USDT池子为例, 价格应该在1附近浮动, 因此将流动性聚集在这里是很棒的, 在V2中, 你只能在$(0,+∞)$添加流动性, 这意味着, 你提供的流动性不管在价格1 还是在 500的时候 起到的作用并没有什么差异, 而两者之间的价格能达到500的情况十分罕见, 所以 这是对于资金效率巨大的浪费. 如果你把相同数量的流动性都放在[0.95, 1.05]不是更好吗. V3则是允许这样做, 可以让市场提供流动性的人 来 自己选择 想要提供流动性的价格范围. 

在V2中 永远不会出现池子里只有一种Token的情况, 即X轴或者Y轴都不可能出现为0的情况. 因此 可以参考下图: 

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220711161622.png)

这里仍然满足 $x*y=k$的公式, 只不过变成了 $(x_r+L/P_b^{0.5})(y-r+LP_a^{0.5})=L^2$, 这个公式 则有可能出现x或者y为0的情况, 这意味着 如果 价格一旦超出了 [a,b] 的这个区间, 那么池子内只会留下一种资产, 比如 Alice提供 AVAX/USDC 流动性, 价格区间则是 [95,105]

- 价格低于95的时候, 池子里面全是AVAX
- 价格在 95 到 105 之间的时候, 池子里则有两种资产
- 价格在105之上的时候, 池子里面全是USDC

目前来看, UniV3 听起来非常棒, 但是人们为什么非常讨厌它呢, V2的成功在于人们在添加流动性的时候非常简单, 并且池子中的流动性都是相同的, 所以可以用LP Token表示, 同样可以轻松的进行收益计算, 非常适合懒惰的投资者. 而在V3中, 没有两个流动性是相同的, 所以只能用LP NFT来表示, 而NFT会让收益计算变得比较复杂. 

除此之外, V3会要求你不断重新调整提供流动性的范围, 以确当前市场价格在你提供的流动性的范围内.

---

#### Curve V2

CurveV2 让Curve首次涉足广义AMM in关于, 其新版本承诺多种不相关资产的低滑点交易.

目前Curve上有三个V2的池子, 它的工作方式类似于CurveV1, 但是在价格锚定方面进行了更新, 即使用**指数移动平均线的内部价格预言机**引用的当前价格为目标

V2的美妙之处在于不想UniV3那样手动调节价格范围, 而是矿池会自动重新平衡预言机价格周围的流动性

举个例子, 比如V2池子里是 BTC/USDT, 当前价格是 \$30000, 那么池子中的绝大部分流动性会聚集在这里, 只有一小部分会分布在更大的价格范围内. 如果价格到了 \$40000, 那么资金池会自动重新平衡, 流动性将会发生变化, 因此大部分流动性重新聚集在 $40000 的焦点这里. 因此, 池子里的每个流动性头寸都是相同的, 并且可以用 LP Token来表示, UniV2的优点又回来了.

然而, 不会有东西是完美无缺的, 如果我们查看数据, 会发现与UniV3相比, 交易量非常非常低. 数据如下: 👇🏻

- CurveV2的Tricypto Pool(BTC, ETH, USDT)
  - TVL = $480M
  - Daily volume = $107M
  - Vol / TVL = 22%
- UniV3 的 USDC/ETh 0.05% Pool
  - TVL = $328M
  - Daily Volume = $693M
  - Vol / TVL = 211%

就兑换率而言, CurveV2几乎低了10倍, 因此 我怀疑可能是以下的几点造成

1. 不友好的用户交互界面
2. CurveV2的定位并不是通用的Dex来宣发
3. 无法容纳长尾资产[即不利于垃圾币交易]

CurveV2的优点

- 同质化的流动性
- 资金效率的提高
- 单一资产的质押

CurveV2的缺点

- 无法提供长尾资产流动性

---

#### TWAMM

全称叫做 **Time-Weighted Average Market Maker** , 由Paradigm的[这篇文章](https://www.paradigm.xyz/2021/07/twamm)提出, 其核心思想在于将大的订单随着时间拆解成小订单, 这样做的结果是有利于更好的按照当前的市场执行成交, 因为在每一笔小的订单完成之后, 如果有足够的价差, 则会有套利者扳平价格

这就是鲸鱼样做的事情, 如果Michael Saylor决定购买一亿美金的ETH的时候, 他会随着时间的推移通过购买更小的块来成交, 效果如下图所示, 最理想的环境则是 Infinite Pieces per order

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220711183658.png)

然而, 由于链上的所有交易都是公开的, 即使是子订单也容易受到抢先交易的影响, 例如 Alice和Bob都想购买AVAX, 谁在后面谁吃亏 因为前面的购买者会推高购买价格. 为了解决这一问题, **买入和卖出组合在一起.** 

那关于三明治攻击, 对交易会产生影响吗?  从技术上讲, 任何公共交易会比较容易受到三明治攻击, 但是随着TWAMM订单在**块与块**之间执行, 使得三明治交易变得比较艰难, **因为攻击者需要确保它是上一个块的最后一个交易者和下一个块的第一个交易者** 

想象一种情况, AVAX目前是100U 池子里面有 1mAVAX 和 100mUSDC, Alice想要将手中的100mUSDC换出去, 而Bob想要将手中的 1mAVAX 换出去.

如果Alice先执行, 那么Alice会获得0.5m的AVAX, Bob获得133m的USDC, Bob获利更大

如果Bob先执行, Bob获得50m的USDC, Alice获得1.33m的AVAX, Alice获利更大

很明显, 在传统UniV2中, 谁在后面执行交易, 谁的获利更大

但是在TWAMM中, 则会变成Alice和Bob直接进行交易, 即Alice用 100mUSDC 获得了 1mAVAX, 而Bob则是用 1mAVAX 获得了 100m的USDC

:heart: 优点

- 允许更大金额的交易, 并且和传统金融很像

:broken_heart: 缺点

- 还是会收到三明治攻击
- 更大的gas花费
- 本身并不是AMM, 而是构建在其他AMM之上的

---

####  RMM

全称为 **Replicating Market Marker**, 其核心在于投资组合和目标收益相匹配的做市商. 由于解释起来太过麻烦, 因此用**Primitive Finance**为例, 在Primitive中, 流动性提供者赚取的费用, 和有担保看涨期权的收益相匹配.

---

##### 有担保看涨期权

这里简单介绍一下期权的基本知识, **看涨期权[Call] 会赋予持有人权利但不是义务 在到期时以设定价格购买某种资产**, 相应的, **看跌期权[Put]会赋予持有人权利但不是义务 在到期时以某种价格售卖某种资产**. 举个例子, 目前6.22号, AVAX的价格是100, Alice从Bob手中, 购买了价格为110的看涨期权, 行权日是7.1号,.

- 如果AVAX涨到了120, 在7.1号, 那么Alice可以从Bob手中, 以110的价位购买AVAX, 然后把它卖掉.
- 如果AVAX只涨到了105, 那么Alice可以选择不用管她的看涨期权, 她只是损失掉了期权购买的费用.

**在传统交易世界中**, 期权是合法执行的合同, 即Bob向Alice出售这张110的期权的时候, 他不必手头上要有足量的AVAX, 但是在AVAX升到120的情况下 Bob需要手头上有足量的AVAX能够卖给Alice, 因此他会被迫在AVAX120的时候大量买入, 才能以110的价格卖个Alice, 这就叫做 **裸call**

**在有担保看涨期权的情况下**, Bob则是必须手头上要有足量的AVAX 才能向Alice出售这张期权, 由于我们没有办法像现实世界一样执行合同条例, 因此这就相当于存进抵押品

 因此, 为什么要作为期权的卖方呢?

假设AVAX当前价格为100, Bob是一个长期多头, 但他认为7.1号之前不会涨到150, 因此 他可以以150的价格出售其AVAX的看涨期权, 并且只要AVAX在7.1号之前低于150美元, 他就可以从期权费用中获利, 即使AVAX涨到140 , 他仍然可以从这里面获利. **即任何上涨对他来说都是有利可图的, 直到价格超过了150美元.**

---

##### 期权定价

在到期之前, 期权的价值通常高于其收益, 比如 明天到期的100美元的AVAX看跌期权[Put]

- 如果当前AVAX的价格是100, 则收益为0
- 但是明天AVAX的价格可能下跌, 这种情况下, 期权的收益则超过0
- 考虑到这种情况, 看跌期权的价格必须必须大于0

一种基本且广泛使用的期权定价模型是**Black-Scholes**模型, 它根据以下内容计算看涨/看跌期权的价格

1. 行权价
2. 当前现货价格
3. 波动性
4. 到期时间
5. 无风险利率

下图表示了 3000美元行使价ETH看跌期权下的 **Black-Scholes价格(蓝色)** 与 **正常以价差定价的期权价格** 的比较 

> 个人理解可能有误, 这里的原文是 **The graph below shows the Black-Scholes price of a $3000 strike ETH put compared to the payoff at various spot ETH prices one day before expiry.**  

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220711200437.png)

---

##### 再看Primitive

就像我们之前说的, 在这里提供流动性就相当于是在写一个有担保的看涨期权, 即你需要像购买期权一样输入到期日和行使价等参数

![](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F02a93498-2aef-435f-9a9b-874a96f7cf67_1970x1480.png)

本质上, 你是在卖出看涨期权, 其中期权费是累积的交易费, 在交易方面, 要知道Primitive的核心共识并不是$x*y=k$的公式, 它使用的是下图中的公式

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220711201540.png)

上面所展示的这条曲线会动态调整

![](https://raw.githubusercontent.com/skydotone/picture-host/master/20220711201700.png)

如果时间是唯一变量, 曲线会变平, 要知道, 可以用等于执行价格的固定价格进行交易, 本质上则像UniV3一样聚集流动性, 但是围绕在执行价格上下. 

假如你提供AVAX/USDC流动性, 以行权价为100U, 行权日期为明天, 

- 如果当前价格90U, 则套利者会在别处购买AVAX, 然后售卖到这个池子中, 池子将完全由AVAX组成
- 如果当前价格100U, 则不会变动
- 如果价格为110U, 则套利者会从这里购买AVAX, 卖到别的地方, 池子里完全是USDC

:heart: 优点

1. 流动性被集中起来了(只不过随着时间改变)
2. 只有当价格超过行权价的时候, 才会有无常损失
3. 允许你对流动性进行定向押注

:broken_heart: 缺点

1. 添加流动性的时候 极其复杂

---

### Part3

---

Part3更多的是 结合上面所述的AMM, 来描述 一个完美的AMM是什么样的.

在市场中, 不同的角色有着不同的目的性, 流动性提供者想要更高的年化, 而项目方则不想, 因为这样会导致通货膨胀和代币倾销, 损害代币持有者的利益, 因此 一个好的AMM应该可以权衡利弊.

各个角色的需求如下 :point_down:

- 交易者
  - 交易的0滑差
  - 可以在上面交易很多种代币
- 流动性提供者
  - 更高的年化
  - 没有无常损失
  - 单币质押
  - 被动化的流动性管理
  - 被保障的资金安全
- 协议拥有者
  - 不依赖于代币排放
  - 包含大量种类的代币
  - 无许可地创建流动性池子
  - 安全性能高 以及 对外部各方的依赖低

---

好的AMM的必要点 :point_down:

1. 交易的0滑差	
2. 安全性
3. 被动流动性管理
4. 种类多样的代币交易

前两点无需解释, 第三点则是因为AMM比之前基于订单薄的Dex更受欢迎的原因, 其更符合散户投资者. 最后一点有些微妙, 因为主流的代币几乎占到了所有Dex交易量的80%以上, 所以, 真的有必要涵盖大量的无用代币吗? **作者的观念是Yes**, 这就是为什么Uni能够超越Balancer和Bancor的原因, 因为它更能捕捉**长尾资产**

---

- 至于上面说的更高的年化, 冲突点在于流动性提供者和协议拥有者, 那么最好的折衷方案则是提供与代币排放无关的收益(比如, 仅取决于交易费用)

- 是否允许单币质押的讨论, 其实也是一个矛盾点, 大多数提供单币质押的协议都要求协议在为流动性选择白名单资产时非常勤奋, 因为一种不良资产可能会影响池中的其他资产. 但这一点就与无许可创建流动性池子矛盾

- 更低的外部依赖, 利用chainlink预言机来投喂价格是很多项目方常用的手法, 但是要知道, chainlink的价格是滞后的, 当时间和价格很正常时, chainlink非常棒, 但是当某个代币的价格在某个时间段内的变化非常明显时, chainlink则无法及时捕捉到代币价格, 这就是当Luna崩盘时, Venus和Blizz Finance如何被人利用的. **另外要知道的一点是, chainlink是从dex来获取数据的**. 此外 chainlink价格投喂 仅仅适用于选定的代币, 这又阻挡了大量种类的代币. 

---

- 结论, 一个完美的DEX理应有如下特点
  - 交易的0滑差
  - 多种类可交易的Token
  - 流动性安全保障
  - 不依赖于外部
  - 不依赖于代币排放
  - 无许可创建流动性池子
  - 被动地流动性管理

